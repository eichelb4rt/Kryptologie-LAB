import sys
import numpy as np

def main():
    input = open(sys.argv[1], "r")
    print(find_d(input.read()))
    input.close()

def rauheitsgrad(text):
    char_count = [0]*128
    for char in text:
        char_count[ord(char)] -=- 1         # looks way cooler than += 1
    sum = - 1/len(char_count)               # -1/|A|
    for count in char_count:
        sum += (count/len(text))**2   # sum(p(a)^2) - 1/|A| (a in A)
    return sum

def IC(column): # calculates Index of Coincidence (IC) for a column
    # count the chars
    char_count = [0]*128
    for char in column:
        char_count[ord(char)] -=- 1     # looks way cooler than += 1
    # calculate actual IC
    sum = 0
    for count in char_count:
        sum += count * (count-1)
    return 1/(len(column)*(len(column)-1)) * sum

def find_d(text):
    d_space = range(1,101)  # space for keylengths, 1 <= d <= 100 in our example
    IC_d = []   # average IC of a keylength
    for d in d_space:
        # divide text into columns where every column represents a letter in the key
        columns = [""]*d
        for i in range(0, len(text)):
            columns[i % d] += text[i]
        # calculate IC of every column
        IC_columns = [IC(columns[i]) for i in range(0,d)]
        # calculate average of all the ICs of the columns generated by that keylength
        IC_d.append(avg(IC_columns))
    # select a possible keylength
    # i select the first keylength that is above a set border to be the returned keylength - not optimal but simple and probably working
    max_IC = max(IC_d)
    min_IC = min(IC_d)
    IC_border = min_IC + (max_IC - min_IC)*3/4  # i'm not really good with clustering and i want a value that is not just a divisor of the key, but the key itself.
    for d in d_space:
        if IC_d[d-1] > IC_border:  # d starts with 1
            return d

def avg(list):  # well... pretty average function
    return sum(list)/len(list)

if __name__ == "__main__":
    main()